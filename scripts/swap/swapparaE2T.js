// We require the Hardhat Runtime Environment explicitly here. This is optional
// but useful for running the script in a standalone fashion through `node <script>`.
//
// When running the script with `npx hardhat run <script>` you'll find the Hardhat
// Runtime Environment's members available in the global scope.
const hre = require("hardhat");

async function main() {

  let provider = hre.ethers.provider;
  let signer = provider.getSigner();

  const myaddr = await signer.getAddress();

  console.log(myaddr);
  console.log(await signer.getBalance());

  // Hardhat always runs the compile task when running scripts with its command
  // line interface.
  //
  // If this script is run directly using `node` you may want to call compile
  // manually to make sure everything is compiled

  await hre.run('compile');

  const ETH = process.env.ETH;
  const USDC = process.env.USDC;


  const swapContract = process.env.SWAP;
  let swap = await hre.ethers.getContractAt("Swap", swapContract, signer);

  // let pararouter = "0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57";
  // let paraproxy = "0x216B4B4Ba9F3e719726886d34a177484278Bfcae";
  // let registerTx = await swap.registerAdapter(
  //   pararouter,
  //   paraproxy,
  //   hre.ethers.utils.formatBytes32String("paraswap")
  // );
  // await registerTx.wait();
  // console.log("para router is registerred");

  // let index = await swap.getAdapterByIndex(0);
  // console.log(index);

  // console.log(hre.ethers.utils.parseBytes32String(index._name));

  // return;

  let e = ethers.utils.parseEther("0.01");
  let overrides = {
    value: e
  };

  let data = "0x54e3f31b0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000000000000000001942000000000000000000000000000000000000000000000000000000000000194200000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000003a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070617261737761702e696f010000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003e000000000000000000000000000000000000000000000000000000000628795341502c400d80d11ec80ef39e69a8ef67a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f3938337f7294fef84e9b2c6d548a93f956cc28100000000000000000000000000000000000000000000000000000000000000e491a32b69000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf127000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000004de447ebdaaa1da5a2907097a15f8c68617752c68523000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000000000000000000000";
 
  let swapTx = await swap.swap(
  	0,
    ETH,
    USDC,
  	e,
  	data,
  	overrides);
  await swapTx.wait()

  console.log("end");



}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
