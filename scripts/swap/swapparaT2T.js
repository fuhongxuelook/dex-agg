// We require the Hardhat Runtime Environment explicitly here. This is optional
// but useful for running the script in a standalone fashion through `node <script>`.
//
// When running the script with `npx hardhat run <script>` you'll find the Hardhat
// Runtime Environment's members available in the global scope.
const hre = require("hardhat");

async function main() {

  let provider = hre.ethers.provider;
  let signer = provider.getSigner();

  const myaddr = await signer.getAddress();

  console.log(myaddr);
  console.log(await signer.getBalance());

  // Hardhat always runs the compile task when running scripts with its command
  // line interface.
  //
  // If this script is run directly using `node` you may want to call compile
  // manually to make sure everything is compiled

  await hre.run('compile');

  const ETH = process.env.ETH;
  const USDC = process.env.USDC;
  const USDT = process.env.USDT;

  const swapContract = process.env.SWAP;
  let swap = await hre.ethers.getContractAt("Swap", swapContract, signer);

  // let pararouter = "0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57";
  // let paraproxy = "0x216B4B4Ba9F3e719726886d34a177484278Bfcae";
  // let registerTx = await swap.registerAdapter(
  //   pararouter,
  //   paraproxy,
  //   hre.ethers.utils.formatBytes32String("paraswap")
  // );
  // await registerTx.wait();
  // console.log("para router is registerred");

  // let index = await swap.getAdapterByIndex(0);
  // console.log(index);

  // console.log(hre.ethers.utils.parseBytes32String(index._name));

  // return;

  let overrides = {
    value: ethers.utils.parseEther("0")
  };

  let data = "0x54e3f31b00000000000000000000000000000000000000000000000000000000000000200000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f00000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000001872b000000000000000000000000000000000000000000000000000000000001872b00000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000003a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070617261737761702e696f010000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003e0000000000000000000000000000000000000000000000000000000006285ffa35896a800d71b11ec899941499ef62184000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f3938337f7294fef84e9b2c6d548a93f956cc28100000000000000000000000000000000000000000000000000000000000000e491a32b690000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000004de44b1f1e2435a9c96f7330faea190ef6a7c8d70001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
 
  let swapTx = await swap.swap(
  	0,
    USDC,
    USDT,
  	100000,
  	data,
  	overrides);
  await swapTx.wait()

  console.log("end");



}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
